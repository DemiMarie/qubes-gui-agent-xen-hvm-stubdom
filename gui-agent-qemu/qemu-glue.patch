--- a/Makefile.objs
+++ b/Makefile.objs
@@ -56,6 +56,7 @@ common-obj-y += hw/
 common-obj-y += replay/
 
 common-obj-y += ui/
+common-obj-y += gui-agent/
 common-obj-y += bt-host.o bt-vhci.o
 bt-host.o-cflags := $(BLUEZ_CFLAGS)
 
--- a/vl.c
+++ b/vl.c
@@ -76,6 +76,7 @@ int main(int argc, char **argv)
 #include "net/slirp.h"
 #include "monitor/monitor.h"
 #include "ui/console.h"
+#include "gui-agent/include/qubes-gui-qemu.h"
 #include "ui/input.h"
 #include "sysemu/sysemu.h"
 #include "sysemu/numa.h"
@@ -154,6 +155,7 @@ static int rtc_date_offset = -1; /* -1 m
 QEMUClockType rtc_clock;
 int vga_interface_type = VGA_NONE;
 static int full_screen = 0;
+static int qubesgui_log_level = 0;
 static int no_frame = 0;
 int no_quit = 0;
 static bool grab_on_hover;
@@ -2071,6 +2073,7 @@ typedef enum DisplayType {
     DT_COCOA,
     DT_GTK,
     DT_EGL,
+    DT_QUBESGUI,
     DT_NONE,
 } DisplayType;
 
@@ -2199,6 +2202,35 @@ static DisplayType select_display(const
         error_report("GTK support is disabled");
         exit(1);
 #endif
+    } else if (strstart(p, "qubes-gui", &opts)) {
+        display = DT_QUBESGUI;
+        while (*opts) {
+            const char *nextopt;
+
+            if (strstart(opts, ",log_level=", &nextopt)) {
+                opts = nextopt;
+                qubesgui_log_level = strtol(opts, (char **) &nextopt, 0);
+                if (nextopt == opts) {
+                    goto invalid_qubesgui_args;
+                }
+            } else if (strstart(opts, ",domid=", &nextopt)) {
+                opts = nextopt;
+                qubesgui_domid = strtoul(opts, (char **) &nextopt, 0);
+                if (nextopt == opts) {
+                    goto invalid_qubesgui_args;
+                }
+            } else {
+            invalid_qubesgui_args:
+                error_report("invalid Qubes GUI option string");
+                exit(1);
+            }
+            opts = nextopt;
+        }
+
+        if (qubesgui_domid == ~0) {
+            error_report("No GUI domain id for Qubes GUI specified");
+            exit(1);
+        }
     } else if (strstart(p, "none", &opts)) {
         display = DT_NONE;
     } else {
@@ -4715,6 +4747,9 @@ int main(int argc, char **argv, char **e
     case DT_GTK:
         gtk_display_init(ds, full_screen, grab_on_hover);
         break;
+    case DT_QUBESGUI:
+        qubesgui_pv_display_init(qubesgui_log_level);
+        break;
     default:
         break;
     }
--- a/hw/display/vga.c
+++ b/hw/display/vga.c
@@ -1527,6 +1527,8 @@ static void vga_draw_graphic(VGACommonSt
     } else {
         share_surface = false;
     }
+    /* XXX: Qubes GUI can't use a shared buffer */
+    share_surface = false;
     if (s->line_offset != s->last_line_offset ||
         disp_width != s->last_width ||
         height != s->last_height ||
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -141,6 +141,7 @@ struct DisplaySurface {
     GLenum gltype;
     GLuint texture;
 #endif
+    uint32_t *xen_refs;
 };
 
 typedef struct QemuUIInfo {
@@ -336,6 +337,11 @@ static inline pixman_format_code_t surfa
     return s->format;
 }
 
+static inline uint32_t *surface_xen_refs(DisplaySurface *s)
+{
+    return s->xen_refs;
+}
+
 #ifdef CONFIG_CURSES
 /* KEY_EVENT is defined in wincon.h and in curses.h. Avoid redefinition. */
 #undef KEY_EVENT
--- a/ui/console.c
+++ b/ui/console.c
@@ -24,6 +24,7 @@
 #include "qemu/osdep.h"
 #include "qemu-common.h"
 #include "ui/console.h"
+#include "gui-agent/include/qubes-gui-qemu.h"
 #include "hw/qdev-core.h"
 #include "qemu/timer.h"
 #include "qmp-commands.h"
@@ -1287,9 +1288,11 @@ static void qemu_alloc_display(DisplaySu
     surface->image = NULL;
 
     surface->format = PIXMAN_x8r8g8b8;
+    uint8_t *data = qubesgui_alloc_surface_data(width, height, &surface->xen_refs);
+    assert(data != NULL);
     surface->image = pixman_image_create_bits(surface->format,
                                               width, height,
-                                              NULL, width * 4);
+                                              (uint32_t *)data, width * 4);
     assert(surface->image != NULL);
 
     surface->flags = QEMU_ALLOCATED_FLAG;
